import os
import joblib
import numpy as np
import tensorflow as tf
from django.shortcuts import render
from django.http import JsonResponse
from django.core.files.storage import FileSystemStorage
from django.views.decorators.csrf import csrf_exempt
from PyPDF2 import PdfReader
from tensorflow.keras.preprocessing.sequence import pad_sequences
import re
import pdfplumber
import fitz  # PyMuPDF

# === Load Models and Tokenizer ===
MODEL_PATH = 'PDFMalware/models17'
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
LSTM_MODEL_PATH = os.path.join(BASE_DIR, 'PDFMalware/models17/js/js_obfuscation_detector_lstm.keras')
TOKENIZER_PATH = os.path.join(BASE_DIR, 'PDFMalware/models17/js/tfidf_vectorizer.pkl')


models = {
    'ensemble': joblib.load(os.path.join(MODEL_PATH, 'ensemble_model.pkl')),
    'gradient_boosting': joblib.load(os.path.join(MODEL_PATH, 'gradient_boosting_model.pkl')),
    'lightgbm': joblib.load(os.path.join(MODEL_PATH, 'lightgbm_model.pkl')),
    'random_forest': joblib.load(os.path.join(MODEL_PATH, 'random_forest_model.pkl')),
    'svm': joblib.load(os.path.join(MODEL_PATH, 'svm_model.pkl')),
    'xgboost': joblib.load(os.path.join(MODEL_PATH, 'xgboost_model.pkl'))
}

# Ensure model and tokenizer exist
if not os.path.exists(LSTM_MODEL_PATH):
    raise FileNotFoundError(f"LSTM model not found at {LSTM_MODEL_PATH}")
if not os.path.exists(TOKENIZER_PATH):
    raise FileNotFoundError(f"Tokenizer not found at {TOKENIZER_PATH}")

lstm_model = tf.keras.models.load_model(LSTM_MODEL_PATH)
tokenizer = joblib.load(TOKENIZER_PATH)

# === Feature Extraction ===
def extract_features_from_pdf(uploaded_file_path):
    """
    Extract general features from a PDF file for malware detection models.
    """
    # Implement your PDF feature extraction logic here
    return np.random.rand(1, 20)  # Example placeholder

def extract_embedded_javascript(pdf_path):
    """
    Extract embedded JavaScript from PDFs, specifically `/OpenAction` JavaScript.
    """
    try:
        reader = PdfReader(pdf_path)
        javascript_code = []
        for page in reader.pages:
            if '/OpenAction' in page.keys():
                action = page['/OpenAction']
                if '/JS' in action:
                    javascript_code.append(action['/JS'])
        return javascript_code
    except Exception as e:
        print(f"Error extracting JavaScript: {e}")
        return []

def extract_full_text(pdf_path):
    """
    Extract full text from a PDF file using pdfplumber.
    """
    full_text = ""
    try:
        with pdfplumber.open(pdf_path) as pdf:
            for page in pdf.pages:
                text = page.extract_text()
                if text:
                    full_text += text + "\n"
    except Exception as e:
        print(f"Error extracting full text from PDF: {e}")
    return full_text

def extract_pdf_streams_and_js(pdf_path):
    """
    Extract JavaScript and embedded streams from PDFs using PyMuPDF and PyPDF2.
    """
    extracted_streams = []

    # Extract streams using PyMuPDF
    pdf_document = fitz.open(pdf_path)
    for xref in range(1, pdf_document.xref_length()):
        try:
            stream = pdf_document.xref_stream(xref)
            if stream:
                extracted_streams.append(stream.decode("utf-8", errors="ignore"))
        except Exception:
            pass
    pdf_document.close()

    # Extract JavaScript using PyPDF2
    try:
        reader = PdfReader(pdf_path)
        for page in reader.pages:
            # Check OpenAction JavaScript
            if '/OpenAction' in page:
                action = page['/OpenAction']
                if '/JS' in action:
                    js_code = action['/JS'].get_object()
                    extracted_streams.append(js_code)
            # Check Additional Action JavaScript
            if '/AA' in page:
                aa_action = page['/AA']
                for key in aa_action:
                    if '/JS' in aa_action[key]:
                        js_code = aa_action[key]['/JS'].get_object()
                        extracted_streams.append(js_code)
    except Exception as e:
        print(f"Error extracting JavaScript: {e}")

    return extracted_streams

# === Obfuscation Detection ===
def extract_obfuscated_code(text):
    """
    Extract obfuscated code from text using advanced patterns.
    """
    patterns = [
        r'\\x[a-fA-F0-9]{2}',        # Hexadecimal encoding
        r'base64',                   # Base64 strings
        r'function\(.{0,10}\)',      # Short function definitions
        r'eval\(.+?\)',              # eval() calls
        r'unescape\(.+?\)',          # unescape() calls
        r'_0x[a-fA-F0-9]+',          # Obfuscated variable names
        r'console\.\w+',             # Obfuscated console calls
        r"'\w{4,}':\[\d+\]",         # Obfuscation via arrays
        r'\bvar\b\s+\w+\s*=',        # Obfuscated variable definitions
        r'\(\w+,\w+\)\{\w+=.+?\}',   # IIFE (Immediately Invoked Function Expressions)
        r'obfuscate|obfuscated',     # Keywords indicating obfuscation
        r'charCodeAt|fromCharCode',  # String manipulation methods
    ]

    extracted_code = []
    for pattern in patterns:
        matches = re.findall(pattern, text)
        extracted_code.extend(matches)

    return extracted_code

def detect_obfuscation(js_code_list):
    """
    Detect obfuscation in a list of JavaScript code snippets using the LSTM model.
    """
    sequences = tokenizer.texts_to_sequences(js_code_list)
    padded_sequences = pad_sequences(sequences, maxlen=500)  # Match the model's input length
    predictions = lstm_model.predict(padded_sequences)
    obfuscation_results = [(pred[0] > 1, pred[0]) for pred in predictions]  # (is_obfuscated, confidence)
    return obfuscation_results

# === Django Views ===
@csrf_exempt
def predict(request):
    if request.method == 'POST' and request.FILES.get('pdf_file'):
        pdf_file = request.FILES['pdf_file']
        fs = FileSystemStorage(location='uploads')
        file_path = fs.save(pdf_file.name, pdf_file)
        uploaded_file_path = os.path.join(fs.location, file_path)

        try:
            # Extract features and JavaScript
            features = extract_features_from_pdf(uploaded_file_path)
            streams = extract_pdf_streams_and_js(uploaded_file_path)
            full_text = extract_full_text(uploaded_file_path)

            # Detect obfuscation
            obfuscation_results = []
            if streams:
                obfuscation_results.extend(detect_obfuscation(streams))
            if full_text:
                obfuscation_results.extend(detect_obfuscation([full_text]))

            # Obfuscation summary
            is_obfuscated = any(result[0] for result in obfuscation_results)
            average_confidence = (
                sum(result[1] for result in obfuscation_results) / len(obfuscation_results)
                if obfuscation_results else 0
            )

            # Model predictions
            model_predictions = {name: model.predict_proba(features) for name, model in models.items()}
            highest_malicious = max((float(pred[0][1] * 100), name) for name, pred in model_predictions.items())
            highest_safe = max((float(pred[0][0] * 100), name) for name, pred in model_predictions.items())

            # Prepare response
            response = {
                'malicious_percentage': highest_malicious[0],
                'most_suspicious_model': highest_malicious[1],
                'safest_percentage': highest_safe[0],
                'safest_model': highest_safe[1],
                'model_probabilities': {
                    name: {
                        'malicious': float(pred[0][1] * 100),
                        'safe': float(pred[0][0] * 100)
                    } for name, pred in model_predictions.items()
                },
                'is_obfuscated': is_obfuscated,
                'obfuscation_confidence': f"{average_confidence * 100:.2f}%",
                'obfuscation_details': obfuscation_results,
                'extracted_pdf_streams': streams,
                'full_text': full_text[:1000],  # Pass first 1000 chars or adjust as needed
            }
            return render(request, 'home.html', {'result': response})

        except Exception as e:
            return render(request, 'home.html', {'result': {'error': str(e)}})

        finally:
            os.remove(uploaded_file_path)
    else:
        return render(request, 'home.html')


@csrf_exempt
def homepage(request):
    """
    Render the homepage with a file upload form.
    """
    return render(request, 'home.html')

